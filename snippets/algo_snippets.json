{
    "IsPrime": {
        "prefix": "algo-is_prime",
        "body": [
            "def is_prime(n: int) -> bool:",
            "\t\"\"\"",
            "\tReturn True if n is prime, False otherwise.",
            "\t\"\"\"",
            "\tif n < 2:",
            "\t\treturn False",
            "\telif n < 4:",
            "\t\treturn True",
            "\telif n % 2 == 0 or n % 3 == 0:",
            "\t\treturn False",
            "\telse:",
            "\t\tfor i in range(5, int(n**0.5)+1, 6):",
            "\t\t\tif n % i == 0 or n % (i+2) == 0:",
            "\t\t\t\treturn False",
            "\t\treturn True"
        ],
        "description": "check whether a number is prime"
    },
    "BinaryExponentiation": {
        "prefix": [
            "algo-binaryExponentiation",
            "algo-fast_power",
            "algo-fast_expo"
        ],
        "body": [
            "def fast_power(x: float, y: int) -> int:\n",
            "\t\"\"\"\n",
            "\tReturn x^y with O(log(n)) Time Complexity.\n",
            "\t\"\"\"\n",
            "\tif y == 0:\n",
            "\t\treturn 1\n",
            "\telif y == 1:\n",
            "\t\treturn x\n",
            "\telif y == -1:\n",
            "\t\treturn 1/x\n",
            "\telse:\n",
            "\t\tans = fast_power(x, y//2)\n",
            "\t\tif y % 2 == 0:\n",
            "\t\t\treturn ans*ans\n",
            "\t\telse:\n",
            "\t\t\treturn ans * ans * x\n"
        ],
        "description": "peforms a^b operation with O(log(n)) Complexity"
    },
    "GreatestCommonDivisor": {
        "prefix": [
            "algo-gcd",
            "algo-hcf"
        ],
        "body": [
            "def greatest_common_divisor(a: int, b: int) -> int:",
            "\t\"\"\"",
            "\tEuclid's Lemma :  d divides a and b, if and only if d divides a-b and b",
            "\tEuclid's Algorithm",
            "",
            "\t>>> greatest_common_divisor(7,5)",
            "\t1",
            "",
            "\tNote : In number theory, two integers a and b are said to be relatively prime,",
            "\t\tmutually prime, or co-prime if the only positive integer (factor) that divides",
            "\t\tboth of them is 1  i.e., gcd(a,b) = 1.",
            "",
            "\t>>> greatest_common_divisor(121, 11)",
            "\t11",
            "\t\"\"\"",
            "\tif a < b:",
            "\t\ta, b = b, a",
            "",
            "\twhile a % b != 0:",
            "\t\ta, b = b, a % b",
            "",
            "\treturn b"
        ],
        "description": "computes Greatest Common Divisor of two number"
    },
    "BinarySearchTree": {
        "prefix": [
            "algo-bst",
            "algo-binary_search_tree"
        ],
        "body": [
            "from __future__ import annotations",
            "from typing import Iterator",
            "",
            "",
            "class Node:",
            "\tdef __init__(self, label: int, parent: Node | None) -> None:",
            "\t\tself.label = label",
            "\t\tself.parent = parent",
            "\t\tself.left: Node | None = None",
            "\t\tself.right: Node | None = None",
            "",
            "",
            "class BinarySearchTree:",
            "\t\"\"\"",
            "\tThis is a python3 implementation of binary search tree using recursion",
            "\t\"\"\"",
            "\tdef __init__(self) -> None:",
            "\t\tself.root: Node | None = None",
            "",
            "\tdef empty(self) -> None:",
            "\t\t\"\"\"",
            "\t\tEmpties the tree",
            "",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> assert t.root is None",
            "\t\t>>> t.put(8)",
            "\t\t>>> assert t.root is not None",
            "\t\t\"\"\"",
            "\t\tself.root = None",
            "",
            "\tdef is_empty(self) -> bool:",
            "\t\t\"\"\"",
            "\t\tChecks if the tree is empty",
            "",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> t.is_empty()",
            "\t\tTrue",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.is_empty()",
            "\t\tFalse",
            "\t\t\"\"\"",
            "\t\treturn self.root is None",
            "",
            "\tdef put(self, label: int) -> None:",
            "\t\t\"\"\"",
            "\t\tPut a new node in the tree",
            "",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> t.put(8)",
            "\t\t>>> assert t.root.parent is None",
            "\t\t>>> assert t.root.label == 8",
            "",
            "\t\t>>> t.put(10)",
            "\t\t>>> assert t.root.right.parent == t.root",
            "\t\t>>> assert t.root.right.label == 10",
            "",
            "\t\t>>> t.put(3)",
            "\t\t>>> assert t.root.left.parent == t.root",
            "\t\t>>> assert t.root.left.label == 3",
            "\t\t\"\"\"",
            "\t\tself.root = self._put(self.root, label)",
            "",
            "\tdef _put(self, node: Node | None, label: int, parent: Node | None = None) -> Node:",
            "\t\tif node is None:",
            "\t\t\tnode = Node(label, parent)",
            "\t\telse:",
            "\t\t\tif label < node.label:",
            "\t\t\t\tnode.left = self._put(node.left, label, node)",
            "\t\t\telif label > node.label:",
            "\t\t\t\tnode.right = self._put(node.right, label, node)",
            "\t\t\telse:",
            "\t\t\t\traise Exception(f\"Node with label {label} already exists\")",
            "",
            "\t\treturn node",
            "",
            "\tdef search(self, label: int) -> Node:",
            "\t\t\"\"\"",
            "\t\tSearches a node in the tree",
            "",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.put(10)",
            "\t\t>>> node = t.search(8)",
            "\t\t>>> assert node.label == 8",
            "",
            "\t\t>>> node = t.search(3)",
            "\t\tTraceback (most recent call last):",
            "\t\t\t...",
            "\t\tException: Node with label 3 does not exist",
            "\t\t\"\"\"",
            "\t\treturn self._search(self.root, label)",
            "",
            "\tdef _search(self, node: Node | None, label: int) -> Node:",
            "\t\tif node is None:",
            "\t\t\traise Exception(f\"Node with label {label} does not exist\")",
            "\t\telse:",
            "\t\t\tif label < node.label:",
            "\t\t\t\tnode = self._search(node.left, label)",
            "\t\t\telif label > node.label:",
            "\t\t\t\tnode = self._search(node.right, label)",
            "",
            "\t\treturn node",
            "",
            "\tdef remove(self, label: int) -> None:",
            "\t\t\"\"\"",
            "\t\tRemoves a node in the tree",
            "",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.put(10)",
            "\t\t>>> t.remove(8)",
            "\t\t>>> assert t.root.label == 10",
            "",
            "\t\t>>> t.remove(3)",
            "\t\tTraceback (most recent call last):",
            "\t\t\t...",
            "\t\tException: Node with label 3 does not exist",
            "\t\t\"\"\"",
            "\t\tnode = self.search(label)",
            "\t\tif node.right and node.left:",
            "\t\t\tlowest_node = self._get_lowest_node(node.right)",
            "\t\t\tlowest_node.left = node.left",
            "\t\t\tlowest_node.right = node.right",
            "\t\t\tnode.left.parent = lowest_node",
            "\t\t\tif node.right:",
            "\t\t\t\tnode.right.parent = lowest_node",
            "\t\t\tself._reassign_nodes(node, lowest_node)",
            "\t\telif not node.right and node.left:",
            "\t\t\tself._reassign_nodes(node, node.left)",
            "\t\telif node.right and not node.left:",
            "\t\t\tself._reassign_nodes(node, node.right)",
            "\t\telse:",
            "\t\t\tself._reassign_nodes(node, None)",
            "",
            "\tdef _reassign_nodes(self, node: Node, new_children: Node | None) -> None:",
            "\t\tif new_children:",
            "\t\t\tnew_children.parent = node.parent",
            "",
            "\t\tif node.parent:",
            "\t\t\tif node.parent.right == node:",
            "\t\t\t\tnode.parent.right = new_children",
            "\t\t\telse:",
            "\t\t\t\tnode.parent.left = new_children",
            "\t\telse:",
            "\t\t\tself.root = new_children",
            "",
            "\tdef _get_lowest_node(self, node: Node) -> Node:",
            "\t\tif node.left:",
            "\t\t\tlowest_node = self._get_lowest_node(node.left)",
            "\t\telse:",
            "\t\t\tlowest_node = node",
            "\t\t\tself._reassign_nodes(node, node.right)",
            "",
            "\t\treturn lowest_node",
            "",
            "\tdef exists(self, label: int) -> bool:",
            "\t\t\"\"\"",
            "\t\tChecks if a node exists in the tree",
            "",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.put(10)",
            "\t\t>>> t.exists(8)",
            "\t\tTrue",
            "",
            "\t\t>>> t.exists(3)",
            "\t\tFalse",
            "\t\t\"\"\"",
            "\t\ttry:",
            "\t\t\tself.search(label)",
            "\t\t\treturn True",
            "\t\texcept Exception:",
            "\t\t\treturn False",
            "",
            "\tdef get_max_label(self) -> int:",
            "\t\t\"\"\"",
            "\t\tGets the max label inserted in the tree",
            "",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> t.get_max_label()",
            "\t\tTraceback (most recent call last):",
            "\t\t\t...",
            "\t\tException: Binary search tree is empty",
            "",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.put(10)",
            "\t\t>>> t.get_max_label()",
            "\t\t10",
            "\t\t\"\"\"",
            "\t\tif self.root is None:",
            "\t\t\traise Exception(\"Binary search tree is empty\")",
            "",
            "\t\tnode = self.root",
            "\t\twhile node.right is not None:",
            "\t\t\tnode = node.right",
            "",
            "\t\treturn node.label",
            "",
            "\tdef get_min_label(self) -> int:",
            "\t\t\"\"\"",
            "\t\tGets the min label inserted in the tree",
            "",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> t.get_min_label()",
            "\t\tTraceback (most recent call last):",
            "\t\t\t...",
            "\t\tException: Binary search tree is empty",
            "",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.put(10)",
            "\t\t>>> t.get_min_label()",
            "\t\t8",
            "\t\t\"\"\"",
            "\t\tif self.root is None:",
            "\t\t\traise Exception(\"Binary search tree is empty\")",
            "",
            "\t\tnode = self.root",
            "\t\twhile node.left is not None:",
            "\t\t\tnode = node.left",
            "",
            "\t\treturn node.label",
            "",
            "\tdef inorder_traversal(self) -> Iterator[Node]:",
            "\t\t\"\"\"",
            "\t\tReturn the inorder traversal of the tree",
            "",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> [i.label for i in t.inorder_traversal()]",
            "\t\t[]",
            "",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.put(10)",
            "\t\t>>> t.put(9)",
            "\t\t>>> [i.label for i in t.inorder_traversal()]",
            "\t\t[8, 9, 10]",
            "\t\t\"\"\"",
            "\t\treturn self._inorder_traversal(self.root)",
            "",
            "\tdef _inorder_traversal(self, node: Node | None) -> Iterator[Node]:",
            "\t\tif node is not None:",
            "\t\t\tyield from self._inorder_traversal(node.left)",
            "\t\t\tyield node",
            "\t\t\tyield from self._inorder_traversal(node.right)",
            "",
            "\tdef preorder_traversal(self) -> Iterator[Node]:",
            "\t\t\"\"\"",
            "\t\tReturn the preorder traversal of the tree",
            "",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> [i.label for i in t.preorder_traversal()]",
            "\t\t[]",
            "",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.put(10)",
            "\t\t>>> t.put(9)",
            "\t\t>>> [i.label for i in t.preorder_traversal()]",
            "\t\t[8, 10, 9]",
            "\t\t\"\"\"",
            "\t\treturn self._preorder_traversal(self.root)",
            "",
            "\tdef _preorder_traversal(self, node: Node | None) -> Iterator[Node]:",
            "\t\tif node is not None:",
            "\t\t\tyield node",
            "\t\t\tyield from self._preorder_traversal(node.left)",
            "\t\t\tyield from self._preorder_traversal(node.right)"
        ],
        "description": "code block for constructing Binary Search Tree"
    },
    "SegmentTree": {
        "prefix": [
            "algo-segment_tree",
            "algo-seg_tree"
        ],
        "body": [
            "import math\n",
            "\n",
            "\n",
            "class SegmentTree:\n",
            "\tdef __init__(self, A):\n",
            "\t\tself.N = len(A)\n",
            "\t\tself.st = [0] * (\n",
            "\t\t\t4 * self.N\n",
            "\t\t)  # approximate the overall size of segment tree with array N\n",
            "\t\tself.build(1, 0, self.N - 1)\n",
            "\t\tself.A = A\n",
            "\n",
            "\tdef left(self, idx):\n",
            "\t\treturn idx * 2\n",
            "\n",
            "\tdef right(self, idx):\n",
            "\t\treturn idx * 2 + 1\n",
            "\n",
            "\tdef build(self, idx, l, r):  # noqa: E741\n",
            "\t\tif l == r:  # noqa: E741\n",
            "\t\t\tself.st[idx] = self.A[l]\n",
            "\t\telse:\n",
            "\t\t\tmid = (l + r) // 2\n",
            "\t\t\tself.build(self.left(idx), l, mid)\n",
            "\t\t\tself.build(self.right(idx), mid + 1, r)\n",
            "\t\t\tself.st[idx] = max(self.st[self.left(idx)], self.st[self.right(idx)])\n",
            "\n",
            "\tdef update(self, a, b, val):\n",
            "\t\treturn self.update_recursive(1, 0, self.N - 1, a - 1, b - 1, val)\n",
            "\n",
            "\tdef update_recursive(self, idx, l, r, a, b, val):  # noqa: E741\n",
            "\t\t\"\"\"\n",
            "\t\tupdate(1, 1, N, a, b, v) for update val v to [a,b]\n",
            "\t\t\"\"\"\n",
            "\t\tif r < a or l > b:\n",
            "\t\t\treturn True\n",
            "\t\tif l == r:  # noqa: E741\n",
            "\t\t\tself.st[idx] = val\n",
            "\t\t\treturn True\n",
            "\t\tmid = (l + r) // 2\n",
            "\t\tself.update_recursive(self.left(idx), l, mid, a, b, val)\n",
            "\t\tself.update_recursive(self.right(idx), mid + 1, r, a, b, val)\n",
            "\t\tself.st[idx] = max(self.st[self.left(idx)], self.st[self.right(idx)])\n",
            "\t\treturn True\n",
            "\n",
            "\tdef query(self, a, b):\n",
            "\t\treturn self.query_recursive(1, 0, self.N - 1, a - 1, b - 1)\n",
            "\n",
            "\tdef query_recursive(self, idx, l, r, a, b):  # noqa: E741\n",
            "\t\t\"\"\"\n",
            "\t\tquery(1, 1, N, a, b) for query max of [a,b]\n",
            "\t\t\"\"\"\n",
            "\t\tif r < a or l > b:\n",
            "\t\t\treturn -math.inf\n",
            "\t\tif l >= a and r <= b:  # noqa: E741\n",
            "\t\t\treturn self.st[idx]\n",
            "\t\tmid = (l + r) // 2\n",
            "\t\tq1 = self.query_recursive(self.left(idx), l, mid, a, b)\n",
            "\t\tq2 = self.query_recursive(self.right(idx), mid + 1, r, a, b)\n",
            "\t\treturn max(q1, q2)\n",
            "\n",
            "\tdef showData(self):\n",
            "\t\tshowList = []\n",
            "\t\tfor i in range(1, self.N + 1):\n",
            "\t\t\tshowList += [self.query(i, i)]\n",
            "\t\tprint(showList)"
        ],
        "description":"code block for building segment tree"
    }
}